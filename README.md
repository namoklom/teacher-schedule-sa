# Teacher Scheduling Optimization using Simulated Annealing

This project implements a weekly teacher scheduling system using the **Simulated Annealing** (SA) algorithm. It ensures that each teacher receives at least one teaching slot, with a maximum of 12 shifts per week, and adheres to various scheduling constraints.

---

## 🚀 Features

- Assigns 45 teachers to 48 available teaching time slots (6 days × 8 shifts, excluding 1 break per day).
- Ensures every teacher receives **at least 1 slot per week**.
- Allows up to 12 shifts per teacher to avoid overload.
- Prevents scheduling on lunch break shifts.
- Uses SA to find a low-cost, optimized timetable.
- Visualizes schedules using heatmaps and color legends.

---

## 🧠 Simulated Annealing Formula for Teacher Scheduling

This section details the mathematical formulation and algorithmic process used in the teacher scheduling optimization using Simulated Annealing (SA).
---

### 1. 🔢 State Representation

Each schedule solution `S` is represented as a matrix of dimension **D × S**:

S = {s_{d,s} | d = 1, ..., D; s = 1, ..., S}

Where:
- `s_{d,s}` is the teacher index scheduled on day `d` and shift `s`.
- A value of `-1` represents a break slot (e.g., lunch break).

---

### 2. 📉 Cost Function

The cost function `C(S)` quantifies how "bad" or "infeasible" a schedule is based on constraint violations:

C(S) = ∑{d=1}^{D} (1000 × I_break(d) + 50 × conflicts_d)
+ ∑{t=1}^{T} 10 × max(0, n_t − M)
+ 2000 × I_unassigned


Where:
- `I_break(d)` = 1 if any teacher is scheduled during a break on day `d`, otherwise 0.
- `conflicts_d` = number of duplicate assignments (same teacher more than once per day `d`).
- `n_t` = total shifts assigned to teacher `t` in a week.
- `M` = 12 (maximum allowed shifts per teacher per week).
- `I_unassigned` = 1 if any teacher has zero shifts, 0 otherwise.

The function heavily penalizes invalid schedules (e.g., missing assignments or break-time violations).

---

### 3. 🔁 Neighbor Transition

A neighboring solution `S'` is generated by randomly modifying a single non-break slot in the schedule:

S' = S with one element s_{d,s} replaced by a randomly selected teacher index.


This allows exploration of the solution space while keeping most of the current schedule intact.

---

### 4. 🎲 Acceptance Probability

The acceptance of a neighboring solution depends on the cost difference `ΔC`:

ΔC = C(S') − C(S)

The acceptance probability is:

P(accept) = {
1 if ΔC ≤ 0
exp(−ΔC / T) if ΔC > 0
}


Where `T` is the current temperature. This means worse solutions can be accepted early in the process to escape local minima.

---

### 5. 🌡️ Temperature Update

The temperature `T` is gradually reduced after each iteration using exponential decay:


Constants used:
- Initial temperature: `T₀ = 3000`
- Minimum temperature: `T_min = 1`
- Cooling rate: `α = 0.9`

---

### 6. 🧮 Full Algorithm

The full Simulated Annealing procedure is as follows:

T_{k+1} = α × T_k where 0 < α < 1

1. **Initialize** random schedule `S` and temperature `T = T₀`.
2. **While** `T > T_min`:
   - For each iteration:
     1. Generate a neighbor solution `S'`.
     2. Compute cost difference: `ΔC = C(S') - C(S)`.
     3. If `ΔC ≤ 0`, accept `S'` as the new solution.
     4. Else, accept `S'` with probability `exp(−ΔC / T)`.
   - Update temperature: `T ← α × T`.
3. **Return** the best solution `S` with the lowest cost found.

This process continues until the system "cools down", effectively searching for a globally optimal or near-optimal teacher schedule.

---
