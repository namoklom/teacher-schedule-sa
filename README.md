# Teacher Scheduling Optimization using Simulated Annealing

This project implements a weekly teacher scheduling system using the **Simulated Annealing** (SA) algorithm. It ensures that each teacher receives at least one teaching slot, with a maximum of 12 shifts per week, and adheres to various scheduling constraints.

---

## ğŸš€ Features

- Assigns 45 teachers to 48 available teaching time slots (6 days Ã— 8 shifts, excluding 1 break per day).
- Ensures every teacher receives **at least 1 slot per week**.
- Allows up to 12 shifts per teacher to avoid overload.
- Prevents scheduling on lunch break shifts.
- Uses SA to find a low-cost, optimized timetable.
- Visualizes schedules using heatmaps and color legends.

---

## ğŸ§  Simulated Annealing Formula for Teacher Scheduling

This section details the mathematical formulation and algorithmic process used in the teacher scheduling optimization using Simulated Annealing (SA).
---

### 1. ğŸ”¢ State Representation

Each schedule solution `S` is represented as a matrix of dimension **D Ã— S**:

S = {s_{d,s} | d = 1, ..., D; s = 1, ..., S}

Where:
- `s_{d,s}` is the teacher index scheduled on day `d` and shift `s`.
- A value of `-1` represents a break slot (e.g., lunch break).

---

### 2. ğŸ“‰ Cost Function

The cost function `C(S)` quantifies how "bad" or "infeasible" a schedule is based on constraint violations:

C(S) = âˆ‘{d=1}^{D} (1000 Ã— I_break(d) + 50 Ã— conflicts_d)
+ âˆ‘{t=1}^{T} 10 Ã— max(0, n_t âˆ’ M)
+ 2000 Ã— I_unassigned


Where:
- `I_break(d)` = 1 if any teacher is scheduled during a break on day `d`, otherwise 0.
- `conflicts_d` = number of duplicate assignments (same teacher more than once per day `d`).
- `n_t` = total shifts assigned to teacher `t` in a week.
- `M` = 12 (maximum allowed shifts per teacher per week).
- `I_unassigned` = 1 if any teacher has zero shifts, 0 otherwise.

The function heavily penalizes invalid schedules (e.g., missing assignments or break-time violations).

---

### 3. ğŸ” Neighbor Transition

A neighboring solution `S'` is generated by randomly modifying a single non-break slot in the schedule:

S' = S with one element s_{d,s} replaced by a randomly selected teacher index.


This allows exploration of the solution space while keeping most of the current schedule intact.

---

### 4. ğŸ² Acceptance Probability

The acceptance of a neighboring solution depends on the cost difference `Î”C`:

Î”C = C(S') âˆ’ C(S)

The acceptance probability is:

P(accept) = {
1 if Î”C â‰¤ 0
exp(âˆ’Î”C / T) if Î”C > 0
}


Where `T` is the current temperature. This means worse solutions can be accepted early in the process to escape local minima.

---

### 5. ğŸŒ¡ï¸ Temperature Update

The temperature `T` is gradually reduced after each iteration using exponential decay:


Constants used:
- Initial temperature: `Tâ‚€ = 3000`
- Minimum temperature: `T_min = 1`
- Cooling rate: `Î± = 0.9`

---

### 6. ğŸ§® Full Algorithm

The full Simulated Annealing procedure is as follows:

T_{k+1} = Î± Ã— T_k where 0 < Î± < 1

1. **Initialize** random schedule `S` and temperature `T = Tâ‚€`.
2. **While** `T > T_min`:
   - For each iteration:
     1. Generate a neighbor solution `S'`.
     2. Compute cost difference: `Î”C = C(S') - C(S)`.
     3. If `Î”C â‰¤ 0`, accept `S'` as the new solution.
     4. Else, accept `S'` with probability `exp(âˆ’Î”C / T)`.
   - Update temperature: `T â† Î± Ã— T`.
3. **Return** the best solution `S` with the lowest cost found.

This process continues until the system "cools down", effectively searching for a globally optimal or near-optimal teacher schedule.

---
